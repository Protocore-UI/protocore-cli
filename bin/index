#!/usr/bin/env node

var os = require('os'),
	fs = require('fs'),
	path = require('path'),
	readline = require('readline'),
	chalk = require('chalk');

var program = require('commander'),
	fse = require('fs-extra');

var product = require('../package.json');

program
	.version(product.version)
	.usage('[options] [dir]')
	.option('-a, --about', 'About Protocore-Cli ' + product.version)
	.parse(process.argv);

function about() {
	console.info("\n\n\tAbout %s | Version: %s", product.name, product.version);
	console.info('\t-----------------------------------------------------------------------');
	console.info('\tProject Name : %s', product.name);
	console.info('');
	console.info('\tDeveloped & maintained by author : %s', product.author);
	console.info('');
	console.info('\tVisit the following link to know about %s', product.name)
	console.info('\tHome: %s', product.homepage);
	console.info('');
	console.info('\tIf you find any bugs, enhancements or questions');
	console.info('\tplease feel free to info it on following link');
	console.info('\tIssues: %s', product.issues.url);
	console.info('');
	console.info('\tThe MIT License (MIT), Copyright (c) 2015 Ashwin Hegde');
	console.info('\t%s', product.licenses.url);
	console.info('\n');

	process.exit(1);
}

if (program.about) {
	about();
}

main();

/**
 * Check if the given directory `path` is empty.
 *
 * @param {String} path
 * @param {Function} fn
 */

function isDirectoryEmpty(path, fn) {
	fs.readdir(path, function(err, files) {
		if (err && 'ENOENT' != err.code) {
			throw err;
		}
		fn(!files || !files.length);
	});
};

/**
 * Get the confirmation for user input.
 *
 * @param {String} message
 * @param {Function} callback
 */

function confirm(message, callback) {
	var rl = readline.createInterface({
		input: process.stdin,
		output: process.stdout
	});

	rl.question(message, function(input) {
		rl.close();
		callback(/^y|Y|yes|ok|true$/i.test(input))
	});
}

function mergeObj() {
	var obj = {},
		i = 0,
		il = arguments.length,
		key;
	for (; i < il; i++) {
		for (key in arguments[i]) {
			if (arguments[i].hasOwnProperty(key)) {
				obj[key] = arguments[i][key];
			}
		}
	}
	return obj;
};

function updateProjectInfo(scaffoldingPath, fn) {
	fse.readJson(scaffoldingPath + '/package.json', function(err, packageObj) {
		if (err) {
			return console.error(err);
		}
		var newPackageObj = mergeObj(packageObj, {
			name: scaffoldingPath
		});
		fse.writeJson(scaffoldingPath + '/package.json', {
			name: newPackageObj
		}, function(err) {
			if (err) {
				console.error(err);
			}
		});
	});
	fse.outputFile(scaffoldingPath + '/README.md', '# ' + scaffoldingPath, function(err) {
		if (err) {
			return console.error(err);
		}
	});
	fn();
};

function generateScaffolding(appName, scaffoldingPath) {
	fse.copy(path.join(__dirname, 'templates/'), scaffoldingPath, function(err) {
		if (err) {
			return console.error(err);
		}

		updateProjectInfo(scaffoldingPath, function() {
			console.log(chalk.green('\nStep 1: I\'m all done. Created "' + chalk.bold.cyan('%s') + '" successfully.\n'), scaffoldingPath);
			console.log(chalk.green("Step 2 Change the current working directory to a \"%s\", execute command: " + chalk.bold.cyan('cd %s\n')), scaffoldingPath, scaffoldingPath);
			console.log(chalk.green("Step 3 Install the required dependencies, execute command: " + chalk.bold.cyan('npm install') + "\n"));
		});
	});
};

function main() {
	var scaffoldingPath = program.args.shift() || '.';
	var appName = path.basename(path.resolve(scaffoldingPath));

	isDirectoryEmpty(scaffoldingPath, function(isEmpty) {
		if (isEmpty) {
			generateScaffolding(appName, scaffoldingPath);
		} else {
			console.log(chalk.yellow("\nWarning: Oh, scaffolding path is not empty!"));
			confirm("Are you sure you want to continue? [Y/N] ", function(isYes) {
				if (isYes) {
					process.stdin.destroy();
					generateScaffolding(appName, scaffoldingPath);
				} else {
					console.log(chalk.red("\nCan't figure this out! aborting...\n"));
					process.exit(1);
				}
			});
		}
	});
};